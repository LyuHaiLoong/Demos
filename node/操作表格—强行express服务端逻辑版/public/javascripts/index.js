// 取消出text或number输入框外的其余标签的tabIndex
// 不取消的话，当标签获取了tab切换的焦点时，回车会触发点击事件
// const allTag = document.getElementsByTagName("*");
// for (const v of allTag) {
//   if (!/text|number/.test(v.type)) v.tabIndex = -1;
// }
// 执行程序
const add = new Add("#id", "#name", "#age", "#job", "#level", "#add"),
  save = new Save("#save"),
  shown = new Shown(),
  del = new Delete("#del", "#delAll"),
  checked = new Check("#checked", "#unchecked", "#all"),
  edit = new Edit(),
  sort = new Sort("#sortId", "#sortAge", "#sortLevel", "#order"),
  order = new Order(".up", ".down", ".del");
// run 
add.init();
save.init();
shown.init();
checked.init();
del.init();
edit.init();
sort.init();
order.init();
// ---------------------------
// ----------实现功能----------
// ---------------------------
// 1、输入员工信息
// 2、批量删除、清空与点击删除对应数据
// 3、根据工号、年龄、职级进行数据从高到低以及从低到高的排序
// 4、全选与取消全选
// 5、显示已选项、未选项、全部项
// 6、单数据的位置移动——上移、下移，移动位置根据显示状态的不同，移动位置不同
// 7、数据的保存
// ---------------------------
// --------可添加未实现功能-----
// ---------------------------
// 1、已选项、未选项、全部项的计数显示
// 2、拖曳移动数据
// 3、zilb压缩请求数据
// ---------------------------
// ----------核心逻辑----------
// ---------------------------
// 1、通过选择操作更改数据，执行其他操作时，数据已经是最新状态
// ---------------------------
// ----------主要逻辑----------
// ---------------------------
// 1、点击选中按钮，根据选中状态修改后台数据
// 2、状态码0、1、2分别对应显示全部状态、显示已选状态、显示未选状态
// 3、根据状态码，后台确认渲染的数据发送渲染后的数据给前台
// 4、选中状态挂载在tbody节点下，作为全局可修改属性，作用于所有功能。如果不挂载在tbody下，作为tbody的属性修改，其他方式将不被全局共享。因为extends继承，不继承指针
// 5、部分功能前端实现更加简单快捷、但是本demo由于单纯为express练习，所以所有功能与后台关联
// ---------------------------
// ----------文件关系--------
// ---------------------------
// 1、super.js作为全局公共属性被其他所有功能继承
// 2、add.js——添加
// 3、check.js——单选与全选
// 4、del.js——批量删除与清空
// 5、edit.js——富文本编辑
// 6、order.js——上移、下移、删除
// 7、save.js——保存
// 8、shown.js——已选、未选、全部的显示切换
// 9、sort.js——排序
// 10、index.js——运行程序
// ---------------------------
// ----------内聚及耦合--------
// ---------------------------
// 1、super中的封装方法，大多数为独立方法，不受class类限制，可通用。部分方法添加了私有变量，修改时需要连同方法中的变量一同修改，复用性低。
// 2、由于所有方法由super统一管理，所以各功能间不具备耦合关系。所有功能与super耦合
// 3、方法封装时，在相互调用间，考虑了参数间的关联，所以复杂方法仍有很大解耦空间
// ---------------------------
// ----------需要强调的属性--------
// ---------------------------
// 1、contenteditable——富文本编辑，通过setAttribute及removeAttribute添加移除，通过设置true或false设置可编辑状态
// 2、previousElementSibling与nextElementSibling，查找同级的，相邻的上下节点
// ---------------------------
// ----------垃圾场----------
// ---------------------------
// 作为废弃思路及方法被保存，某些思路感觉其实还说得过去……不做注释